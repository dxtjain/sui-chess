import { useCurrentAccount, useSuiClient } from '@mysten/dapp-kit';
import { Transaction } from '@mysten/sui/transactions';
import { useState } from 'react';

export interface RandomnessState {
  isLoading: boolean;
  error: string | null;
  lastRandomValue: number | null;
}

export const useRandomness = () => {
  const client = useSuiClient();
  const account = useCurrentAccount();
  
  const [state, setState] = useState<RandomnessState>({
    isLoading: false,
    error: null,
    lastRandomValue: null,
  });

  const getRandomnessForAI = async (): Promise<number> => {
    if (!account) {
      throw new Error('No account connected');
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // Create a transaction to get randomness from Sui's beacon
      const tx = new Transaction();
      
      // In a real implementation, you would call the random module
      // For now, we'll simulate this with a transaction that includes randomness
      const randomObject = '0x8'; // Sui's randomness object ID
      
      // Call the random module (this is a simplified version)
      tx.moveCall({
        target: `${randomObject}::random::new_generator`,
        arguments: [tx.object(randomObject)],
      });

      // Execute the transaction to get randomness
      const result = await client.signAndExecuteTransaction({
        signer: account,
        transaction: tx,
        options: {
          showEffects: true,
          showObjectChanges: true,
        },
      });

      // Extract randomness from transaction result
      const randomValue = extractRandomnessFromResult(result);
      
      setState(prev => ({
        ...prev,
        isLoading: false,
        lastRandomValue: randomValue,
      }));

      return randomValue;
    } catch (error) {
      console.error('Error getting randomness:', error);
      
      // Fallback to pseudo-random for development
      const fallbackValue = Math.floor(Math.random() * 100);
      
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: 'Failed to get blockchain randomness, using fallback',
        lastRandomValue: fallbackValue,
      }));

      return fallbackValue;
    }
  };

  // Get randomness without blockchain interaction (for offline play)
  const getPseudoRandomness = (): number => {
    const value = Math.floor(Math.random() * 100);
    setState(prev => ({
      ...prev,
      lastRandomValue: value,
      error: null,
    }));
    return value;
  };

  // Get weighted randomness based on game difficulty
  const getWeightedRandomness = (difficulty: 'easy' | 'medium' | 'hard'): number => {
    let baseRandomness = getPseudoRandomness();
    
    // Adjust randomness based on difficulty
    switch (difficulty) {
      case 'easy':
        // More randomness = weaker AI
        baseRandomness = Math.min(baseRandomness + 30, 100);
        break;
      case 'medium':
        // Moderate randomness
        baseRandomness = Math.min(baseRandomness + 15, 100);
        break;
      case 'hard':
        // Less randomness = stronger AI
        baseRandomness = Math.max(baseRandomness - 20, 0);
        break;
    }
    
    return baseRandomness;
  };

  return {
    ...state,
    getRandomnessForAI,
    getPseudoRandomness,
    getWeightedRandomness,
  };
};

// Helper function to extract randomness from transaction result
function extractRandomnessFromResult(result: any): number {
  try {
    // In a real implementation, you would parse the transaction effects
    // to extract the random value generated by the Sui randomness beacon
    
    // For now, we'll simulate this by generating a value based on the transaction digest
    const digest = result.digest;
    if (digest) {
      // Create a pseudo-random value from the transaction digest
      let hash = 0;
      for (let i = 0; i < digest.length; i++) {
        const char = digest.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      return Math.abs(hash) % 100;
    }
  } catch (error) {
    console.error('Error extracting randomness from result:', error);
  }
  
  // Fallback to standard random
  return Math.floor(Math.random() * 100);
} 